{"version":3,"file":"errorWatch.min.js","sources":["../src/config.js","../src/utils.js","../src/computeStackTrace.js","../src/resourceError.js","../src/report.js","../src/wrap.js","../src/tryCatch.js","../src/index.js"],"sourcesContent":["//Default options:\nexport const remoteFetching = false;     // 获取远程源文件，没什么用关掉\nexport const collectWindowErrors = true; // 是否通知 window 全局错误，开启，关掉了这个脚本就没意义了\nexport const collectSourceErrors = true; // 是否在捕获阶段获取资源加载错误，默认开启\nexport const linesOfContext = 11;        // 5 lines before, the offending line, 5 lines after，没啥用\nexport const debug = false;\nexport const reportFuncName = 'ErrorWatch.report';\n","/**\n * A better form of hasOwnProperty<br/>\n * Example: `_has(MainHostObject, property) === true/false`\n *\n * @param {Object} object to check property\n * @param {string} key to check\n * @return {Boolean} true if the object has the key and it is not inherited\n */\nexport function _has(object, key) {\n  return Object.prototype.hasOwnProperty.call(object, key);\n}\n\n/**\n * Returns true if the parameter is undefined<br/>\n * Example: `_isUndefined(val) === true/false`\n *\n * @param {*} what Value to check\n * @return {Boolean} true if undefined and false otherwise\n */\nexport function _isUndefined(what) {\n  return typeof what === 'undefined';\n}","/**\n * An object representing a single stack frame.\n * @typedef {Object} StackFrame\n * @property {string} url The JavaScript or HTML file URL.\n * @property {string} func The function name, or empty for anonymous functions (if guessing did not work).\n * @property {string[]?} args The arguments passed to the function, if known.\n * @property {number=} line The line number, if known.\n * @property {number=} column The column number, if known.\n * @property {string[]} context An array of source code lines; the middle element corresponds to the correct line#.\n * @memberof ErrorWatch\n */\n/**\n * An object representing a JavaScript stack trace.\n * @typedef {Object} StackTrace\n * @property {string} name The name of the thrown exception.\n * @property {string} message The exception error message.\n * @property {ErrorWatch.StackFrame[]} stack An array of stack frames.\n * @property {string} mode 'stack', 'stacktrace', 'multiline', 'callers', 'onerror', or 'failed' -- method used to collect the stack trace.\n * @memberof ErrorWatch\n */\n/**\n * ErrorWatch.computeStackTrace: cross-browser stack traces in JavaScript\n *\n * Syntax:\n *   ```js\n *   s = ErrorWatch.computeStackTrace.ofCaller([depth])\n *   s = ErrorWatch.computeStackTrace(exception) // consider using ErrorWatch.report instead (see below)\n *   ```\n *\n * Supports:\n *   - Firefox:  full stack trace with line numbers and unreliable column\n *               number on top frame\n *   - Opera 10: full stack trace with line and column numbers\n *   - Opera 9-: full stack trace with line numbers\n *   - Chrome:   full stack trace with line and column numbers\n *   - Safari:   line and column number for the topmost stacktrace element\n *               only\n *   - IE:       no line numbers whatsoever\n *\n * Tries to guess names of anonymous functions by looking for assignments\n * in the source code. In IE and Safari, we have to guess source file names\n * by searching for function bodies inside all page scripts. This will not\n * work for scripts that are loaded cross-domain.\n * Here be dragons: some function names may be guessed incorrectly, and\n * duplicate functions may be mismatched.\n *\n * ErrorWatch.computeStackTrace should only be used for tracing purposes.\n * Logging of unhandled exceptions should be done with ErrorWatch.report,\n * which builds on top of ErrorWatch.computeStackTrace and provides better\n * IE support by utilizing the window.onerror event to retrieve information\n * about the top of the stack.\n *\n * Note: In IE and Safari, no stack trace is recorded on the Error object,\n * so computeStackTrace instead walks its *own* chain of callers.\n * This means that:\n *  * in Safari, some methods may be missing from the stack trace;\n *  * in IE, the topmost function in the stack trace will always be the\n *    caller of computeStackTrace.\n *\n * This is okay for tracing (because you are likely to be calling\n * computeStackTrace from the function you want to be the topmost element\n * of the stack trace anyway), but not okay for logging unhandled\n * exceptions (because your catch block will likely be far away from the\n * inner function that actually caused the exception).\n *\n * Tracing example:\n *  ```js\n *     function trace(message) {\n *         var stackInfo = ErrorWatch.computeStackTrace.ofCaller();\n *         var data = message + \"\\n\";\n *         for(var i in stackInfo.stack) {\n *             var item = stackInfo.stack[i];\n *             data += (item.func || '[anonymous]') + \"() in \" + item.url + \":\" + (item.line || '0') + \"\\n\";\n *         }\n *         if (window.console)\n *             console.info(data);\n *         else\n *             alert(data);\n *     }\n * ```\n * @memberof ErrorWatch\n * @namespace\n */\nimport { remoteFetching, linesOfContext, debug, reportFuncName } from './config';\nimport { _has, _isUndefined } from './utils';\n\nconst UNKNOWN_FUNCTION = '?';\n\nlet sourceCache = {};\n\n/**\n * Attempts to retrieve source code via XMLHttpRequest, which is used\n * to look up anonymous function names.\n * @param {string} url URL of source code.\n * @return {string} Source contents.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction loadSource(url) {\n  if (!remoteFetching) { //Only attempt request if remoteFetching is on.\n    return '';\n  }\n  try {\n    const getXHR = function() {\n      try {\n        return new window.XMLHttpRequest();\n      } catch (e) {\n        // explicitly bubble up the exception if not found\n        return new window.ActiveXObject('Microsoft.XMLHTTP');\n      }\n    };\n\n    const request = getXHR();\n    request.open('GET', url, false);\n    request.send('');\n    return request.responseText;\n  } catch (e) {\n    return '';\n  }\n}\n\n/**\n * Retrieves source code from the source code cache.\n * @param {string} url URL of source code.\n * @return {Array.<string>} Source contents.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction getSource(url) {\n  if (typeof url !== 'string') {\n    return [];\n  }\n\n  if (!_has(sourceCache, url)) {\n    // URL needs to be able to fetched within the acceptable domain.  Otherwise,\n    // cross-domain errors will be triggered.\n    /*\n        Regex matches:\n        0 - Full Url\n        1 - Protocol\n        2 - Domain\n        3 - Port (Useful for internal applications)\n        4 - Path\n    */\n    let source = '',\n        domain = '';\n    try { domain = window.document.domain; } catch (e) { }\n    const match = /(.*)\\:\\/\\/([^:\\/]+)([:\\d]*)\\/{0,1}([\\s\\S]*)/.exec(url);\n    if (match && match[2] === domain) {\n      source = loadSource(url);\n    }\n    sourceCache[url] = source ? source.split('\\n') : [];\n  }\n\n  return sourceCache[url];\n}\n\n/**\n * Tries to use an externally loaded copy of source code to determine\n * the name of a function by looking at the name of the variable it was\n * assigned to, if any.\n * @param {string} url URL of source code.\n * @param {(string|number)} lineNo Line number in source code.\n * @return {string} The function name, if discoverable.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction guessFunctionName(url, lineNo) {\n  const reFunctionArgNames = /function ([^(]*)\\(([^)]*)\\)/,\n    reGuessFunction = /['\"]?([0-9A-Za-z$_]+)['\"]?\\s*[:=]\\s*(function|eval|new Function)/,\n    maxLines = 10,\n    source = getSource(url);\n  let line = '', m;\n\n  if (!source.length) {\n    return UNKNOWN_FUNCTION;\n  }\n\n  // Walk backwards from the first line in the function until we find the line which\n  // matches the pattern above, which is the function definition\n  for (let i = 0; i < maxLines; ++i) {\n    line = source[lineNo - i] + line;\n\n    if (!_isUndefined(line)) { // 这里有个bug，永远为 true\n      if ((m = reGuessFunction.exec(line))) {\n        return m[1];\n      } else if ((m = reFunctionArgNames.exec(line))) {\n        return m[1];\n      }\n    }\n  }\n\n  return UNKNOWN_FUNCTION;\n}\n\n/**\n * Retrieves the surrounding lines from where an exception occurred.\n * @param {string} url URL of source code.\n * @param {(string|number)} line Line number in source code to center around for context.\n * @return {?Array.<string>} Lines of source code.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction gatherContext(url, line) {\n  const source = getSource(url);\n\n  if (!source.length) {\n    return null;\n  }\n\n  let context = [],\n    // linesBefore & linesAfter are inclusive with the offending line.\n    // if linesOfContext is even, there will be one extra line\n    //   *before* the offending line.\n    linesBefore = Math.floor(linesOfContext / 2),\n    // Add one extra line if linesOfContext is odd\n    linesAfter = linesBefore + (linesOfContext % 2),\n    start = Math.max(0, line - linesBefore - 1),\n    end = Math.min(source.length, line + linesAfter - 1);\n\n  line -= 1; // convert to 0-based index\n\n  for (let i = start; i < end; ++i) {\n    if (!_isUndefined(source[i])) {\n      context.push(source[i]);\n    }\n  }\n\n  return context.length > 0 ? context : null;\n}\n\n/**\n * Escapes special characters, except for whitespace, in a string to be\n * used inside a regular expression as a string literal.\n * @param {string} text The string.\n * @return {string} The escaped string literal.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction escapeRegExp(text) {\n  return text.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#]/g, '\\\\$&');\n}\n\n/**\n * Escapes special characters in a string to be used inside a regular\n * expression as a string literal. Also ensures that HTML entities will\n * be matched the same as their literal friends.\n * @param {string} body The string.\n * @return {string} The escaped string.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction escapeCodeAsRegExpForMatchingInsideHTML(body) {\n  return escapeRegExp(body).replace('<', '(?:<|&lt;)').replace('>', '(?:>|&gt;)').replace('&', '(?:&|&amp;)').replace('\"', '(?:\"|&quot;)').replace(/\\s+/g, '\\\\s+');\n}\n\n/**\n * Determines where a code fragment occurs in the source code.\n * @param {RegExp} re The function definition.\n * @param {Array.<string>} urls A list of URLs to search.\n * @return {?Object.<string, (string|number)>} An object containing\n * the url, line, and column number of the defined function.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction findSourceInUrls(re, urls) {\n  let source, m;\n  for (let i = 0, j = urls.length; i < j; ++i) {\n    if ((source = getSource(urls[i])).length) {\n      source = source.join('\\n');\n      if ((m = re.exec(source))) {\n\n        return {\n          'url': urls[i],\n          'line': source.substring(0, m.index).split('\\n').length,\n          'column': m.index - source.lastIndexOf('\\n', m.index) - 1\n        };\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Determines at which column a code fragment occurs on a line of the\n * source code.\n * @param {string} fragment The code fragment.\n * @param {string} url The URL to search.\n * @param {(string|number)} line The line number to examine.\n * @return {?number} The column number.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction findSourceInLine(fragment, url, line) {\n  const source = getSource(url),\n    re = new RegExp('\\\\b' + escapeRegExp(fragment) + '\\\\b');\n  let m;\n\n  line -= 1;\n\n  if (source && source.length > line && (m = re.exec(source[line]))) {\n    return m.index;\n  }\n\n  return null;\n}\n\n/**\n * Determines where a function was defined within the source code.\n * @param {(Function|string)} func A function reference or serialized\n * function definition.\n * @return {?Object.<string, (string|number)>} An object containing\n * the url, line, and column number of the defined function.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction findSourceByFunctionBody(func) {\n  if (_isUndefined(window && window.document)) {\n    return null;\n  }\n\n  const urls = [window.location.href],\n    scripts = window.document.getElementsByTagName('script'),\n    code = '' + func,\n    codeRE = /^function(?:\\s+([\\w$]+))?\\s*\\(([\\w\\s,]*)\\)\\s*\\{\\s*(\\S[\\s\\S]*\\S)\\s*\\}\\s*$/,\n    eventRE = /^function on([\\w$]+)\\s*\\(event\\)\\s*\\{\\s*(\\S[\\s\\S]*\\S)\\s*\\}\\s*$/;\n  let body,\n    re,\n    parts,\n    result;\n\n  for (let i = 0; i < scripts.length; ++i) {\n    const script = scripts[i];\n    if (script.src) {\n      urls.push(script.src);\n    }\n  }\n\n  if (!(parts = codeRE.exec(code))) {\n    re = new RegExp(escapeRegExp(code).replace(/\\s+/g, '\\\\s+'));\n  }\n\n  // not sure if this is really necessary, but I don’t have a test\n  // corpus large enough to confirm that and it was in the original.\n  else {\n    const name = parts[1] ? '\\\\s+' + parts[1] : '',\n      args = parts[2].split(',').join('\\\\s*,\\\\s*');\n\n    body = escapeRegExp(parts[3]).replace(/;$/, ';?'); // semicolon is inserted if the function ends with a comment.replace(/\\s+/g, '\\\\s+');\n    re = new RegExp('function' + name + '\\\\s*\\\\(\\\\s*' + args + '\\\\s*\\\\)\\\\s*{\\\\s*' + body + '\\\\s*}');\n  }\n\n  // look for a normal function definition\n  if ((result = findSourceInUrls(re, urls))) {\n    return result;\n  }\n\n  // look for an old-school event handler function\n  if ((parts = eventRE.exec(code))) {\n    const event = parts[1];\n    body = escapeCodeAsRegExpForMatchingInsideHTML(parts[2]);\n\n    // look for a function defined in HTML as an onXXX handler\n    re = new RegExp('on' + event + '=[\\\\\\'\"]\\\\s*' + body + '\\\\s*[\\\\\\'\"]', 'i');\n\n    if ((result = findSourceInUrls(re, urls[0]))) {\n      return result;\n    }\n\n    // look for ???\n    re = new RegExp(body);\n\n    if ((result = findSourceInUrls(re, urls))) {\n      return result;\n    }\n  }\n\n  return null;\n}\n\n// Contents of Exception in various browsers.\n//\n// SAFARI:\n// ex.message = Can't find variable: qq\n// ex.line = 59\n// ex.sourceId = 580238192\n// ex.sourceURL = http://...\n// ex.expressionBeginOffset = 96\n// ex.expressionCaretOffset = 98\n// ex.expressionEndOffset = 98\n// ex.name = ReferenceError\n//\n// FIREFOX:\n// ex.message = qq is not defined\n// ex.fileName = http://...\n// ex.lineNumber = 59\n// ex.columnNumber = 69\n// ex.stack = ...stack trace... (see the example below)\n// ex.name = ReferenceError\n//\n// CHROME:\n// ex.message = qq is not defined\n// ex.name = ReferenceError\n// ex.type = not_defined\n// ex.arguments = ['aa']\n// ex.stack = ...stack trace...\n//\n// INTERNET EXPLORER:\n// ex.message = ...\n// ex.name = ReferenceError\n//\n// OPERA:\n// ex.message = ...message... (see the example below)\n// ex.name = ReferenceError\n// ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n// ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\n/**\n * Computes stack trace information from the stack property.\n * Chrome and Gecko use this property.\n * @param {Error} ex\n * @return {?ErrorWatch.StackTrace} Stack trace information.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction computeStackTraceFromStackProp(ex) {\n  if (!ex.stack) {\n    return null;\n  }\n\n  const chrome = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\/).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i,\n    gecko = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i,\n    winjs = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i,\n\n    geckoEval = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i,\n    chromeEval = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/,\n\n    lines = ex.stack.split('\\n'),\n    reference = /^(.*) is undefined$/.exec(ex.message);\n  let stack = [],\n    // Used to additionally parse URL/line/column from eval frames\n    isEval,\n    submatch,\n    parts,\n    element;\n\n  for (let i = 0, j = lines.length; i < j; ++i) {\n    if ((parts = chrome.exec(lines[i]))) {\n      const isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n      isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n      if (isEval && (submatch = chromeEval.exec(parts[2]))) {\n        // throw out eval line/column and use top-most line/column number\n        parts[2] = submatch[1]; // url\n        parts[3] = submatch[2]; // line\n        parts[4] = submatch[3]; // column\n      }\n      element = {\n        'url': !isNative ? parts[2] : null,\n        'func': parts[1] || UNKNOWN_FUNCTION,\n        'args': isNative ? [parts[2]] : [],\n        'line': parts[3] ? +parts[3] : null,\n        'column': parts[4] ? +parts[4] : null\n      };\n    } else if ( parts = winjs.exec(lines[i]) ) {\n      element = {\n        'url': parts[2],\n        'func': parts[1] || UNKNOWN_FUNCTION,\n        'args': [],\n        'line': +parts[3],\n        'column': parts[4] ? +parts[4] : null\n      };\n    } else if ((parts = gecko.exec(lines[i]))) {\n      isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n      if (isEval && (submatch = geckoEval.exec(parts[3]))) {\n        // throw out eval line/column and use top-most line number\n        parts[3] = submatch[1];\n        parts[4] = submatch[2];\n        parts[5] = null; // no column when eval\n      } else if (i === 0 && !parts[5] && !_isUndefined(ex.columnNumber)) {\n        // FireFox uses this awesome columnNumber property for its top frame\n        // Also note, Firefox's column number is 0-based and everything else expects 1-based,\n        // so adding 1\n        // NOTE: this hack doesn't work if top-most frame is eval\n        stack[0].column = ex.columnNumber + 1;\n      }\n      element = {\n        'url': parts[3],\n        'func': parts[1] || UNKNOWN_FUNCTION,\n        'args': parts[2] ? parts[2].split(',') : [],\n        'line': parts[4] ? +parts[4] : null,\n        'column': parts[5] ? +parts[5] : null\n      };\n    } else {\n      continue;\n    }\n\n    if (!element.func && element.line) {\n      element.func = guessFunctionName(element.url, element.line);\n    }\n\n    element.context = element.line ? gatherContext(element.url, element.line) : null;\n    stack.push(element);\n  }\n\n  if (!stack.length) {\n    return null;\n  }\n\n  if (stack[0] && stack[0].line && !stack[0].column && reference) {\n    stack[0].column = findSourceInLine(reference[1], stack[0].url, stack[0].line);\n  }\n\n  return {\n    'mode': 'stack',\n    'name': ex.name,\n    'message': ex.message,\n    'stack': stack\n  };\n}\n\n/**\n * Computes stack trace information from the stacktrace property.\n * Opera 10+ uses this property.\n * @param {Error} ex\n * @return {?ErrorWatch.StackTrace} Stack trace information.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction computeStackTraceFromStacktraceProp(ex) {\n  // Access and store the stacktrace property before doing ANYTHING\n  // else to it because Opera is not very good at providing it\n  // reliably in other circumstances.\n  const stacktrace = ex.stacktrace;\n  if (!stacktrace) {\n    return;\n  }\n\n  const opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i,\n    opera11Regex = / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^\\)]+))\\((.*)\\))? in (.*):\\s*$/i,\n    lines = stacktrace.split('\\n');\n  let stack = [],\n    parts;\n\n  for (let line = 0; line < lines.length; line += 2) {\n    let element = null;\n    if ((parts = opera10Regex.exec(lines[line]))) {\n      element = {\n        'url': parts[2],\n        'line': +parts[1],\n        'column': null,\n        'func': parts[3],\n        'args':[]\n      };\n    } else if ((parts = opera11Regex.exec(lines[line]))) {\n      element = {\n        'url': parts[6],\n        'line': +parts[1],\n        'column': +parts[2],\n        'func': parts[3] || parts[4],\n        'args': parts[5] ? parts[5].split(',') : []\n      };\n    }\n\n    if (element) {\n      if (!element.func && element.line) {\n        element.func = guessFunctionName(element.url, element.line);\n      }\n      if (element.line) {\n        try {\n          element.context = gatherContext(element.url, element.line);\n        } catch (exc) {}\n      }\n\n      if (!element.context) {\n        element.context = [lines[line + 1]];\n      }\n\n      stack.push(element);\n    }\n  }\n\n  if (!stack.length) {\n    return null;\n  }\n\n  return {\n    'mode': 'stacktrace',\n    'name': ex.name,\n    'message': ex.message,\n    'stack': stack\n  };\n}\n\n/**\n * NOT TESTED.\n * Computes stack trace information from an error message that includes\n * the stack trace.\n * Opera 9 and earlier use this method if the option to show stack\n * traces is turned on in opera:config.\n * @param {Error} ex\n * @return {?ErrorWatch.StackTrace} Stack information.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction computeStackTraceFromOperaMultiLineMessage(ex) {\n  // TODO: Clean this function up\n  // Opera includes a stack trace into the exception message. An example is:\n  //\n  // Statement on line 3: Undefined variable: undefinedFunc\n  // Backtrace:\n  //   Line 3 of linked script file://localhost/Users/andreyvit/Projects/ErrorWatch/javascript-client/sample.js: In function zzz\n  //         undefinedFunc(a);\n  //   Line 7 of inline#1 script in file://localhost/Users/andreyvit/Projects/ErrorWatch/javascript-client/sample.html: In function yyy\n  //           zzz(x, y, z);\n  //   Line 3 of inline#1 script in file://localhost/Users/andreyvit/Projects/ErrorWatch/javascript-client/sample.html: In function xxx\n  //           yyy(a, a, a);\n  //   Line 1 of function script\n  //     try { xxx('hi'); return false; } catch(ex) { ErrorWatch.report(ex); }\n  //   ...\n\n  const lines = ex.message.split('\\n');\n  if (lines.length < 4) {\n    return null;\n  }\n\n  const lineRE1 = /^\\s*Line (\\d+) of linked script ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i,\n    lineRE2 = /^\\s*Line (\\d+) of inline#(\\d+) script in ((?:file|https?|blob)\\S+)(?:: in function (\\S+))?\\s*$/i,\n    lineRE3 = /^\\s*Line (\\d+) of function script\\s*$/i,\n    stack = [],\n    scripts = (window && window.document && window.document.getElementsByTagName('script'));\n  let inlineScriptBlocks = [],\n    parts;\n\n  for (let s in scripts) {\n    if (_has(scripts, s) && !scripts[s].src) {\n      inlineScriptBlocks.push(scripts[s]);\n    }\n  }\n\n  for (let line = 2; line < lines.length; line += 2) {\n    let item = null;\n    if ((parts = lineRE1.exec(lines[line]))) {\n      item = {\n        'url': parts[2],\n        'func': parts[3],\n        'args': [],\n        'line': +parts[1],\n        'column': null\n      };\n    } else if ((parts = lineRE2.exec(lines[line]))) {\n      item = {\n        'url': parts[3],\n        'func': parts[4],\n        'args': [],\n        'line': +parts[1],\n        'column': null // TODO: Check to see if inline#1 (+parts[2]) points to the script number or column number.\n      };\n      const relativeLine = (+parts[1]); // relative to the start of the <SCRIPT> block\n      const script = inlineScriptBlocks[parts[2] - 1];\n      if (script) {\n        let source = getSource(item.url);\n        if (source) {\n          source = source.join('\\n');\n          const pos = source.indexOf(script.innerText);\n          if (pos >= 0) {\n            item.line = relativeLine + source.substring(0, pos).split('\\n').length;\n          }\n        }\n      }\n    } else if ((parts = lineRE3.exec(lines[line]))) {\n      const url = window.location.href.replace(/#.*$/, '');\n      const re = new RegExp(escapeCodeAsRegExpForMatchingInsideHTML(lines[line + 1]));\n      const src = findSourceInUrls(re, [url]);\n      item = {\n        'url': url,\n        'func': '',\n        'args': [],\n        'line': src ? src.line : parts[1],\n        'column': null\n      };\n    }\n\n    if (item) {\n      if (!item.func) {\n        item.func = guessFunctionName(item.url, item.line);\n      }\n      const context = gatherContext(item.url, item.line);\n      const midline = (context ? context[Math.floor(context.length / 2)] : null);\n      if (context && midline.replace(/^\\s*/, '') === lines[line + 1].replace(/^\\s*/, '')) {\n        item.context = context;\n      } else {\n        // if (context) alert(\"Context mismatch. Correct midline:\\n\" + lines[i+1] + \"\\n\\nMidline:\\n\" + midline + \"\\n\\nContext:\\n\" + context.join(\"\\n\") + \"\\n\\nURL:\\n\" + item.url);\n        item.context = [lines[line + 1]];\n      }\n      stack.push(item);\n    }\n  }\n  if (!stack.length) {\n    return null; // could not parse multiline exception message as Opera stack trace\n  }\n\n  return {\n    'mode': 'multiline',\n    'name': ex.name,\n    'message': lines[0],\n    'stack': stack\n  };\n}\n\n/**\n * Adds information about the first frame to incomplete stack traces.\n * Safari and IE require this to get complete data on the first frame.\n * @param {ErrorWatch.StackTrace} stackInfo Stack trace information from\n * one of the compute* methods.\n * @param {string} url The URL of the script that caused an error.\n * @param {(number|string)} lineNo The line number of the script that\n * caused an error.\n * @param {string=} message The error generated by the browser, which\n * hopefully contains the name of the object that caused the error.\n * @return {boolean} Whether or not the stack information was\n * augmented.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {\n  let initial = {\n    'url': url,\n    'line': lineNo\n  };\n\n  if (initial.url && initial.line) {\n    stackInfo.incomplete = false;\n\n    if (!initial.func) {\n      initial.func = guessFunctionName(initial.url, initial.line);\n    }\n\n    if (!initial.context) {\n      initial.context = gatherContext(initial.url, initial.line);\n    }\n\n    const reference = / '([^']+)' /.exec(message);\n    if (reference) {\n      initial.column = findSourceInLine(reference[1], initial.url, initial.line);\n    }\n\n    if (stackInfo.stack.length > 0) {\n      if (stackInfo.stack[0].url === initial.url) {\n        if (stackInfo.stack[0].line === initial.line) {\n          return false; // already in stack trace\n        } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {\n          stackInfo.stack[0].line = initial.line;\n          stackInfo.stack[0].context = initial.context;\n          return false;\n        }\n      }\n    }\n\n    stackInfo.stack.unshift(initial);\n    stackInfo.partial = true;\n    return true;\n  } else {\n    stackInfo.incomplete = true;\n  }\n\n  return false;\n}\n\n/**\n * Computes stack trace information by walking the arguments.caller\n * chain at the time the exception occurred. This will cause earlier\n * frames to be missed but is the only way to get any stack trace in\n * Safari and IE. The top frame is restored by\n * {@link augmentStackTraceWithInitialElement}.\n * @param {Error} ex\n * @return {ErrorWatch.StackTrace=} Stack trace information.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction computeStackTraceByWalkingCallerChain(ex, depth) {\n  const functionName = /function\\s+([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?\\s*\\(/i;\n  let stack = [],\n    funcs = {},\n    recursion = false,\n    parts,\n    item,\n    source;\n\n  for (let curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {\n    if (curr === computeStackTrace || (curr && curr.__name__ === reportFuncName)) { // curr ===  report 避免循环依赖\n      continue;\n    }\n\n    item = {\n      'url': null,\n      'func': UNKNOWN_FUNCTION,\n      'args': [],\n      'line': null,\n      'column': null\n    };\n\n    if (curr.name) {\n      item.func = curr.name;\n    } else if ((parts = functionName.exec(curr.toString()))) {\n      item.func = parts[1];\n    }\n\n    if (typeof item.func === 'undefined') {\n      try {\n        item.func = parts.input.substring(0, parts.input.indexOf('{'));\n      } catch (e) { }\n    }\n\n    if ((source = findSourceByFunctionBody(curr))) {\n      item.url = source.url;\n      item.line = source.line;\n\n      if (item.func === UNKNOWN_FUNCTION) {\n        item.func = guessFunctionName(item.url, item.line);\n      }\n\n      const reference = / '([^']+)' /.exec(ex.message || ex.description);\n      if (reference) {\n        item.column = findSourceInLine(reference[1], source.url, source.line);\n      }\n    }\n\n    if (funcs['' + curr]) {\n      recursion = true;\n    }else{\n      funcs['' + curr] = true;\n    }\n\n    stack.push(item);\n  }\n\n  if (depth) {\n    stack.splice(0, depth);\n  }\n\n  let result = {\n    'mode': 'callers',\n    'name': ex.name,\n    'message': ex.message,\n    'stack': stack\n  };\n  augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);\n  return result;\n}\n\n/**\n * Computes a stack trace for an exception.\n * @param {Error} ex\n * @param {(string|number)=} depth\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction computeStackTrace(ex, depth) {\n  let stack = null;\n  depth = (depth == null ? 0 : +depth);\n\n  try {\n    // This must be tried first because Opera 10 *destroys*\n    // its stacktrace property if you try to access the stack\n    // property first!!\n    stack = computeStackTraceFromStacktraceProp(ex);\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n\n  try {\n    stack = computeStackTraceFromStackProp(ex);\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n\n  try {\n    stack = computeStackTraceFromOperaMultiLineMessage(ex);\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n\n  try {\n    stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n\n  return {\n    'name': ex.name,\n    'message': ex.message,\n    'mode': 'failed'\n  };\n}\n\n/**\n * Logs a stacktrace starting from the previous call and working down.\n * @param {(number|string)=} depth How many frames deep to trace.\n * @return {ErrorWatch.StackTrace} Stack trace information.\n * @memberof ErrorWatch.computeStackTrace\n */\nfunction computeStackTraceOfCaller(depth) {\n  depth = (depth == null ? 0 : +depth) + 1; // \"+ 1\" because \"ofCaller\" should drop one frame\n  try {\n    throw new Error();\n  } catch (ex) {\n    return computeStackTrace(ex, depth + 1);\n  }\n}\n\ncomputeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;\ncomputeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;\ncomputeStackTrace.guessFunctionName = guessFunctionName;\ncomputeStackTrace.gatherContext = gatherContext;\ncomputeStackTrace.ofCaller = computeStackTraceOfCaller;\ncomputeStackTrace.getSource = getSource;\n\nexport default computeStackTrace;\n","import { collectSourceErrors } from './config';\n\nlet isRegisterListener = false;\nlet _handler = null;\n\n/**\n * 资源加载错误上报\n * @param handler\n */\nexport function installResourceLoadError(handler) {\n  if(!isRegisterListener && collectSourceErrors) {\n    _handler = handler;\n    window.addEventListener && window.addEventListener('error', function (e) {\n      try {\n        if(e.target !== window) {  // 避免重复上报\n          const stack = {\n            message: `${e.target.localName} is load error`,\n            mode: 'resource',\n            name: e.target.src || e.target.href || e.target.currentSrc,\n            stack: null,\n          };\n          handler(stack, true, e);\n        }\n      } catch (e) {\n        throw e;\n      }\n    }, true);\n  }\n  isRegisterListener = true;\n}\n\n/**\n * 移除资源错误加载监听\n */\nexport function uninstallResourceLoadError() {\n  if(isRegisterListener && collectSourceErrors && _handler) {\n    window.removeEventListener && window.removeEventListener('error', _handler);\n    _handler = null;\n    isRegisterListener = false;\n  }\n}\n","/**\n * Cross-browser processing of unhandled exceptions\n *\n * Syntax:\n * ```js\n *   ErrorWatch.report.subscribe(function(stackInfo) { ... })\n *   ErrorWatch.report.unsubscribe(function(stackInfo) { ... })\n *   ErrorWatch.report(exception)\n *   try { ...code... } catch(ex) { ErrorWatch.report(ex); }\n * ```\n *\n * Supports:\n *   - Firefox: full stack trace with line numbers, plus column number\n *     on top frame; column number is not guaranteed\n *   - Opera: full stack trace with line and column numbers\n *   - Chrome: full stack trace with line and column numbers\n *   - Safari: line and column number for the top frame only; some frames\n *     may be missing, and column number is not guaranteed\n *   - IE: line and column number for the top frame only; some frames\n *     may be missing, and column number is not guaranteed\n *\n * In theory, ErrorWatch should work on all of the following versions:\n *   - IE5.5+ (only 8.0 tested)\n *   - Firefox 0.9+ (only 3.5+ tested)\n *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n *     Exceptions Have Stacktrace to be enabled in opera:config)\n *   - Safari 3+ (only 4+ tested)\n *   - Chrome 1+ (only 5+ tested)\n *   - Konqueror 3.5+ (untested)\n *\n * Requires ErrorWatch.computeStackTrace.\n *\n * Tries to catch all unhandled exceptions and report them to the\n * subscribed handlers. Please note that ErrorWatch.report will rethrow the\n * exception. This is REQUIRED in order to get a useful stack trace in IE.\n * If the exception does not reach the top of the browser, you will only\n * get a stack trace from the point where ErrorWatch.report was called.\n *\n * Handlers receive a ErrorWatch.StackTrace object as described in the\n * ErrorWatch.computeStackTrace docs.\n *\n * @memberof ErrorWatch\n * @namespace\n */\n\nimport computeStackTrace from './computeStackTrace';\nimport {collectWindowErrors, reportFuncName} from './config';\nimport { _has } from './utils';\nimport { installResourceLoadError, uninstallResourceLoadError } from './resourceError';\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nconst ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;\n\n\nlet handlers = [],\n  lastException = null,\n  lastExceptionStack = null;\n\n/**\n * Add a crash handler.\n * @param {Function} handler\n * @memberof ErrorWatch.report\n */\nfunction subscribe(handler) {\n  installGlobalHandler();\n  installGlobalUnhandledRejectionHandler();\n  handlers.push(handler);\n}\n\n/**\n * Remove a crash handler.\n * @param {Function} handler\n * @memberof ErrorWatch.report\n */\nfunction unsubscribe(handler) {\n  for (let i = handlers.length - 1; i >= 0; --i) {\n    if (handlers[i] === handler) {\n      handlers.splice(i, 1);\n    }\n  }\n\n  if (handlers.length === 0) {\n    uninstallGlobalHandler();\n    uninstallGlobalUnhandledRejectionHandler();\n  }\n}\n\n/**\n * Dispatch stack information to all handlers.\n * @param {ErrorWatch.StackTrace} stack\n * @param {boolean} isWindowError Is this a top-level window error?\n * @param {Error=} error The error that's being handled (if available, null otherwise)\n * @memberof ErrorWatch.report\n * @throws An exception if an error occurs while calling an handler.\n */\nfunction notifyHandlers(stack, isWindowError, error) {\n  let exception = null;\n  if (isWindowError && !collectWindowErrors) {\n    return;\n  }\n  for (let i in handlers) {\n    if (_has(handlers, i)) {\n      try {\n        handlers[i](stack, isWindowError, error);\n      } catch (inner) {\n        exception = inner;\n      }\n    }\n  }\n\n  if (exception) {\n    throw exception;\n  }\n}\n\nlet _oldOnerrorHandler, _onErrorHandlerInstalled;\nlet _oldOnunhandledrejectionHandler, _onUnhandledRejectionHandlerInstalled;\n\n/**\n * Ensures all global unhandled exceptions are recorded.\n * Supported by Gecko and IE.\n * @param {string} message Error message.\n * @param {string} url URL of script that generated the exception.\n * @param {(number|string)} lineNo The line number at which the error occurred.\n * @param {(number|string)=} columnNo The column number at which the error occurred.\n * @param {Error=} errorObj The actual Error object.\n * @memberof ErrorWatch.report\n */\nfunction errorWatchWindowOnError(message, url, lineNo, columnNo, errorObj) {\n  let stack = null;\n\n  if (lastExceptionStack) {\n    computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);\n    processLastException();\n  } else if (errorObj) {\n    stack = computeStackTrace(errorObj);\n    notifyHandlers(stack, true, errorObj);\n  } else {\n    let location = {\n      'url': url,\n      'line': lineNo,\n      'column': columnNo\n    };\n\n    let name;\n    let msg = message; // must be new var or will modify original `arguments`\n    if ({}.toString.call(message) === '[object String]') {\n      const groups = message.match(ERROR_TYPES_RE);\n      if (groups) {\n        name = groups[1];\n        msg = groups[2];\n      }\n    }\n\n    location.func = computeStackTrace.guessFunctionName(location.url, location.line);\n    location.context = computeStackTrace.gatherContext(location.url, location.line);\n    stack = {\n      'name': name,\n      'message': msg,\n      'mode': 'onerror',\n      'stack': [location]\n    };\n\n    notifyHandlers(stack, true, null);\n  }\n\n  if (_oldOnerrorHandler) {\n    return _oldOnerrorHandler.apply(this, arguments);\n  }\n\n  return false;\n}\n\n/**\n * Ensures all unhandled rejections are recorded.\n * @param {PromiseRejectionEvent} e event.\n * @memberof ErrorWatch.report\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onunhandledrejection\n * @see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent\n */\nfunction errorWatchWindowOnUnhandledRejection(e) {\n  const stack = computeStackTrace(e.reason);\n  notifyHandlers(stack, true, e.reason);\n}\n\n/**\n * Install a global onerror handler\n * @memberof ErrorWatch.report\n */\nfunction installGlobalHandler() {\n  if (_onErrorHandlerInstalled === true) {\n    return;\n  }\n\n  _oldOnerrorHandler = window.onerror;\n  window.onerror = errorWatchWindowOnError;\n  installResourceLoadError(function handleResourceError(stack, isWindowError, error) {\n    notifyHandlers(stack, isWindowError, error);\n  });\n  _onErrorHandlerInstalled = true;\n}\n\n/**\n * Uninstall the global onerror handler\n * @memberof ErrorWatch.report\n */\nfunction uninstallGlobalHandler() {\n  if (_onErrorHandlerInstalled) {\n    window.onerror = _oldOnerrorHandler;\n    uninstallResourceLoadError();\n    _onErrorHandlerInstalled = false;\n  }\n}\n\n/**\n * Install a global onunhandledrejection handler\n * @memberof ErrorWatch.report\n */\nfunction installGlobalUnhandledRejectionHandler() {\n  if (_onUnhandledRejectionHandlerInstalled === true) {\n    return;\n  }\n\n  _oldOnunhandledrejectionHandler = window.onunhandledrejection;\n  window.onunhandledrejection = errorWatchWindowOnUnhandledRejection;\n  _onUnhandledRejectionHandlerInstalled = true;\n}\n\n/**\n * Uninstall the global onunhandledrejection handler\n * @memberof ErrorWatch.report\n */\nfunction uninstallGlobalUnhandledRejectionHandler() {\n  if (_onUnhandledRejectionHandlerInstalled) {\n    window.onunhandledrejection = _oldOnunhandledrejectionHandler;\n    _onUnhandledRejectionHandlerInstalled = false;\n  }\n}\n\n/**\n * Process the most recent exception\n * @memberof ErrorWatch.report\n */\nfunction processLastException() {\n  let _lastExceptionStack = lastExceptionStack,\n    _lastException = lastException;\n  lastExceptionStack = null;\n  lastException = null;\n  notifyHandlers(_lastExceptionStack, false, _lastException);\n}\n\n/**\n * Reports an unhandled Error to ErrorWatch.\n * @param {Error} ex\n * @memberof ErrorWatch.report\n * @throws An exception if an incomplete stack trace is detected (old IE browsers).\n */\nfunction report(ex) {\n  if (lastExceptionStack) {\n    if (lastException === ex) {\n      return; // already caught by an inner catch block, ignore\n    } else {\n      processLastException();\n    }\n  }\n\n  const stack = computeStackTrace(ex);\n  lastExceptionStack = stack;\n  lastException = ex;\n\n  // If the stack trace is incomplete, wait for 2 seconds for\n  // slow slow IE to see if onerror occurs or not before reporting\n  // this exception; otherwise, we will end up with an incomplete\n  // stack trace\n  setTimeout(function () {\n    if (lastException === ex) {\n      processLastException();\n    }\n  }, (stack.incomplete ? 2000 : 0));\n\n  throw ex; // re-throw to propagate to the top level (and cause window.onerror)\n}\n\nreport.subscribe = subscribe;\nreport.unsubscribe = unsubscribe;\n\nreport.__name__ = reportFuncName;\n\nexport default report;\n","import report from \"./report\";\n\n/**\n * Wrap any function in a ErrorWatch reporter<br/>\n * Example: `func = ErrorWatch.wrap(func);`\n *\n * @param {Function} func Function to be wrapped\n * @return {Function} The wrapped func\n * @memberof ErrorWatch\n */\nexport function wrap(func) {\n  function wrapped() {\n    try {\n      return func.apply(this, arguments);\n    } catch (e) {\n      report(e);\n      throw e;\n    }\n  }\n  return wrapped;\n}\n","import { wrap } from './wrap';\n\n// global reference to slice\nconst _slice = [].slice;\n\n/**\n * Extends support for global error handling for asynchronous browser\n * functions. Adopted from Closure Library's errorhandler.js\n * @memberof ErrorWatch\n */\nfunction _helper(fnName) {\n  const originalFn = window[fnName];\n\n  window[fnName] = function errorWatchAsyncExtension() {\n    // Make a copy of the arguments\n    let args = _slice.call(arguments);\n    const originalCallback = args[0];\n    if (typeof (originalCallback) === 'function') {\n      args[0] = wrap(originalCallback);\n    }\n    // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it\n    // also only supports 2 argument and doesn't care what \"this\" is, so we\n    // can just call the original function directly.\n    if (originalFn.apply) {\n      return originalFn.apply(this, args);\n    } else {\n      return originalFn(args[0], args[1]);\n    }\n  };\n}\n\nexport function extendToAsynchronousCallbacks() {\n  _helper('setTimeout');\n  _helper('setInterval');\n}\n","import report from './report';\nimport computeStackTrace from './computeStackTrace';\nimport {wrap} from './wrap';\nimport { extendToAsynchronousCallbacks } from './tryCatch';\n\nconst _oldErrorWatch = window.ErrorWatch;\nlet ErrorWatch;\n/**\n * Export ErrorWatch out to another variable<br/>\n * Example: `var TK = ErrorWatch.noConflict()`\n * @return {Object} The ErrorWatch object\n * @memberof ErrorWatch\n */\nfunction noConflict() {\n  window.ErrorWatch = _oldErrorWatch;\n  return ErrorWatch;\n}\n\nfunction makeError() {\n  const tmp = thisIsAbug;\n  return tmp + '';\n}\n\nErrorWatch =  {\n  noConflict,\n  report,\n  computeStackTrace,\n  wrap,\n  extendToAsynchronousCallbacks,\n  makeError,\n};\n\nexport default ErrorWatch;\n"],"names":["collectWindowErrors","collectSourceErrors","linesOfContext","reportFuncName","_has","object","key","Object","prototype","hasOwnProperty","call","_isUndefined","what","UNKNOWN_FUNCTION","sourceCache","getSource","url","source","domain","window","document","e","match","exec","split","guessFunctionName","lineNo","m","reFunctionArgNames","reGuessFunction","line","length","i","gatherContext","context","linesBefore","Math","floor","linesAfter","start","max","end","min","push","escapeRegExp","text","replace","escapeCodeAsRegExpForMatchingInsideHTML","body","findSourceInUrls","re","urls","j","join","substring","index","lastIndexOf","findSourceInLine","fragment","RegExp","computeStackTraceFromStackProp","ex","stack","submatch","parts","element","chrome","gecko","winjs","geckoEval","chromeEval","lines","reference","message","isNative","indexOf","columnNumber","column","func","name","augmentStackTraceWithInitialElement","stackInfo","initial","incomplete","unshift","partial","computeStackTraceByWalkingCallerChain","depth","item","functionName","funcs","recursion","curr","caller","computeStackTrace","__name__","toString","input","result","args","location","href","scripts","getElementsByTagName","code","script","src","event","findSourceByFunctionBody","description","splice","sourceURL","fileName","lineNumber","stacktrace","opera10Regex","opera11Regex","exc","computeStackTraceFromStacktraceProp","lineRE1","lineRE2","lineRE3","inlineScriptBlocks","s","relativeLine","pos","midline","innerText","computeStackTraceFromOperaMultiLineMessage","ofCaller","Error","isRegisterListener","_handler","_oldOnerrorHandler","_onErrorHandlerInstalled","_oldOnunhandledrejectionHandler","_onUnhandledRejectionHandlerInstalled","ERROR_TYPES_RE","handlers","lastException","lastExceptionStack","notifyHandlers","isWindowError","error","exception","inner","errorWatchWindowOnError","columnNo","errorObj","msg","groups","processLastException","apply","this","arguments","errorWatchWindowOnUnhandledRejection","reason","_lastExceptionStack","_lastException","report","setTimeout","wrap","subscribe","handler","onerror","addEventListener","target","localName","mode","currentSrc","installResourceLoadError","installGlobalHandler","onunhandledrejection","installGlobalUnhandledRejectionHandler","unsubscribe","removeEventListener","_slice","slice","_helper","fnName","originalFn","originalCallback","ErrorWatch","_oldErrorWatch","noConflict","extendToAsynchronousCallbacks","makeError","thisIsAbug"],"mappings":"gMAEO,IAAMA,GAAsB,EACtBC,GAAsB,EACtBC,EAAiB,GAEjBC,EAAiB,oBCEvB,SAASC,EAAKC,EAAQC,UACpBC,OAAOC,UAAUC,eAAeC,KAAKL,EAAQC,GAU/C,SAASK,EAAaC,eACJ,IAATA,ECkEhB,IAAMC,EAAmB,IAErBC,EAAc,GAsClB,SAASC,EAAUC,MACE,iBAARA,QACF,OAGJZ,EAAKU,EAAaE,GAAM,KAWvBC,EAAS,GACTC,EAAS,OACPA,EAASC,OAAOC,SAASF,OAAU,MAAOG,QAC1CC,EAAQ,8CAA8CC,KAAKP,GAC7DM,GAASA,EAAM,KAAOJ,IACxBD,EAhDK,IAkDPH,EAAYE,GAAOC,EAASA,EAAOO,MAAM,MAAQ,UAG5CV,EAAYE,GAYrB,SAASS,EAAkBT,EAAKU,OAKfC,EAJTC,EAAqB,8BACzBC,EAAkB,mEAElBZ,EAASF,EAAUC,GACjBc,EAAO,OAENb,EAAOc,cACHlB,MAKJ,IAAImB,EAAI,EAAGA,EAVH,KAUmBA,MAGzBrB,EAFLmB,EAAOb,EAAOS,EAASM,GAAKF,GAEH,IAClBH,EAAIE,EAAgBN,KAAKO,UACrBH,EAAE,GACJ,GAAKA,EAAIC,EAAmBL,KAAKO,UAC/BH,EAAE,UAKRd,EAUT,SAASoB,EAAcjB,EAAKc,OACpBb,EAASF,EAAUC,OAEpBC,EAAOc,cACH,SAGLG,EAAU,GAIZC,EAAcC,KAAKC,MAAMnC,EAAiB,GAE1CoC,EAAaH,EAAejC,EAAiB,EAC7CqC,EAAQH,KAAKI,IAAI,EAAGV,EAAOK,EAAc,GACzCM,EAAML,KAAKM,IAAIzB,EAAOc,OAAQD,EAAOQ,EAAa,KAEpDR,MAEK,IAAIE,EAAIO,EAAOP,EAAIS,IAAOT,EACxBrB,EAAaM,EAAOe,KACvBE,EAAQS,KAAK1B,EAAOe,WAIA,EAAjBE,EAAQH,OAAaG,EAAU,KAUxC,SAASU,EAAaC,UACbA,EAAKC,QAAQ,4BAA6B,QAWnD,SAASC,EAAwCC,UACxCJ,EAAaI,GAAMF,QAAQ,IAAK,cAAcA,QAAQ,IAAK,cAAcA,QAAQ,IAAK,eAAeA,QAAQ,IAAK,gBAAgBA,QAAQ,OAAQ,QAW3J,SAASG,EAAiBC,EAAIC,WACxBlC,EAAQU,EACHK,EAAI,EAAGoB,EAAID,EAAKpB,OAAQC,EAAIoB,IAAKpB,MACnCf,EAASF,EAAUoC,EAAKnB,KAAKD,SAChCd,EAASA,EAAOoC,KAAK,MAChB1B,EAAIuB,EAAG3B,KAAKN,UAER,KACEkC,EAAKnB,QACJf,EAAOqC,UAAU,EAAG3B,EAAE4B,OAAO/B,MAAM,MAAMO,cACvCJ,EAAE4B,MAAQtC,EAAOuC,YAAY,KAAM7B,EAAE4B,OAAS,UAMzD,KAYT,SAASE,EAAiBC,EAAU1C,EAAKc,OAGnCH,EAFEV,EAASF,EAAUC,GACvBkC,EAAK,IAAIS,OAAO,MAAQf,EAAac,GAAY,eAGnD5B,EAEIb,GAAUA,EAAOc,OAASD,IAASH,EAAIuB,EAAG3B,KAAKN,EAAOa,KACjDH,EAAE4B,MAGJ,KAuHT,SAASK,EAA+BC,OACjCA,EAAGC,aACC,aAePC,EACAC,EACAC,EAdIC,EAAS,8HACbC,EAAQ,kIACRC,EAAQ,gHAERC,EAAY,gDACZC,EAAa,gCAEbC,EAAQV,EAAGC,MAAMtC,MAAM,MACvBgD,EAAY,sBAAsBjD,KAAKsC,EAAGY,SACxCX,EAAQ,GAOH9B,EAAI,EAAGoB,EAAImB,EAAMxC,OAAQC,EAAIoB,IAAKpB,EAAG,IACvCgC,EAAQE,EAAO3C,KAAKgD,EAAMvC,IAAM,KAC7B0C,EAAWV,EAAM,IAAqC,IAA/BA,EAAM,GAAGW,QAAQ,UACrCX,EAAM,IAAmC,IAA7BA,EAAM,GAAGW,QAAQ,UACvBZ,EAAWO,EAAW/C,KAAKyC,EAAM,OAE9CA,EAAM,GAAKD,EAAS,GACpBC,EAAM,GAAKD,EAAS,GACpBC,EAAM,GAAKD,EAAS,IAEtBE,EAAU,KACAS,EAAsB,KAAXV,EAAM,QACjBA,EAAM,IAAMnD,OACZ6D,EAAW,CAACV,EAAM,IAAM,QACxBA,EAAM,IAAMA,EAAM,GAAK,YACrBA,EAAM,IAAMA,EAAM,GAAK,WAE9B,GAAKA,EAAQI,EAAM7C,KAAKgD,EAAMvC,IACnCiC,EAAU,KACDD,EAAM,QACLA,EAAM,IAAMnD,OACZ,SACCmD,EAAM,UACLA,EAAM,IAAMA,EAAM,GAAK,UAE9B,CAAA,KAAKA,EAAQG,EAAM5C,KAAKgD,EAAMvC,cAC1BgC,EAAM,KAAqC,EAA/BA,EAAM,GAAGW,QAAQ,aACvBZ,EAAWM,EAAU9C,KAAKyC,EAAM,MAE7CA,EAAM,GAAKD,EAAS,GACpBC,EAAM,GAAKD,EAAS,GACpBC,EAAM,GAAK,MACI,IAANhC,GAAYgC,EAAM,IAAOrD,EAAakD,EAAGe,gBAKlDd,EAAM,GAAGe,OAAShB,EAAGe,aAAe,GAEtCX,EAAU,KACDD,EAAM,QACLA,EAAM,IAAMnD,OACZmD,EAAM,GAAKA,EAAM,GAAGxC,MAAM,KAAO,QACjCwC,EAAM,IAAMA,EAAM,GAAK,YACrBA,EAAM,IAAMA,EAAM,GAAK,OAMhCC,EAAQa,MAAQb,EAAQnC,OAC3BmC,EAAQa,KAAOrD,EAAkBwC,EAAQjD,IAAKiD,EAAQnC,OAGxDmC,EAAQ/B,QAAU+B,EAAQnC,KAAOG,EAAcgC,EAAQjD,IAAKiD,EAAQnC,MAAQ,KAC5EgC,EAAMnB,KAAKsB,UAGRH,EAAM/B,QAIP+B,EAAM,IAAMA,EAAM,GAAGhC,OAASgC,EAAM,GAAGe,QAAUL,IACnDV,EAAM,GAAGe,OAASpB,EAAiBe,EAAU,GAAIV,EAAM,GAAG9C,IAAK8C,EAAM,GAAGhC,OAGnE,MACG,aACA+B,EAAGkB,aACAlB,EAAGY,cACLX,IAXF,KAwNX,SAASkB,EAAoCC,EAAWjE,EAAKU,EAAQ+C,OAC/DS,EAAU,KACLlE,OACCU,MAGNwD,EAAQlE,KAAOkE,EAAQpD,KAAM,CAC/BmD,EAAUE,YAAa,EAElBD,EAAQJ,OACXI,EAAQJ,KAAOrD,EAAkByD,EAAQlE,IAAKkE,EAAQpD,OAGnDoD,EAAQhD,UACXgD,EAAQhD,QAAUD,EAAciD,EAAQlE,IAAKkE,EAAQpD,WAGjD0C,EAAY,cAAcjD,KAAKkD,MACjCD,IACFU,EAAQL,OAASpB,EAAiBe,EAAU,GAAIU,EAAQlE,IAAKkE,EAAQpD,OAG1C,EAAzBmD,EAAUnB,MAAM/B,QACdkD,EAAUnB,MAAM,GAAG9C,MAAQkE,EAAQlE,IAAK,IACtCiE,EAAUnB,MAAM,GAAGhC,OAASoD,EAAQpD,YAC/B,EACF,IAAKmD,EAAUnB,MAAM,GAAGhC,MAAQmD,EAAUnB,MAAM,GAAGgB,OAASI,EAAQJ,YACzEG,EAAUnB,MAAM,GAAGhC,KAAOoD,EAAQpD,KAClCmD,EAAUnB,MAAM,GAAG5B,QAAUgD,EAAQhD,SAC9B,SAKb+C,EAAUnB,MAAMsB,QAAQF,GACxBD,EAAUI,SAAU,UAGpBJ,EAAUE,YAAa,GAgB3B,SAASG,EAAsCzB,EAAI0B,WAK/CvB,EACAwB,EACAvE,EAmCQuD,EAzCJiB,EAAe,qEACjB3B,EAAQ,GACV4B,EAAQ,GACRC,GAAY,EAKLC,EAAON,EAAsCO,OAAQD,IAASD,EAAWC,EAAOA,EAAKC,YACxFD,IAASE,GAAsBF,GAAQA,EAAKG,WAAa5F,OAI7DqF,EAAO,KACE,UACC3E,OACA,QACA,YACE,MAGR+E,EAAKb,KACPS,EAAKV,KAAOc,EAAKb,MACPf,EAAQyB,EAAalE,KAAKqE,EAAKI,eACzCR,EAAKV,KAAOd,EAAM,SAGK,IAAdwB,EAAKV,SAEZU,EAAKV,KAAOd,EAAMiC,MAAM3C,UAAU,EAAGU,EAAMiC,MAAMtB,QAAQ,MACzD,MAAOtD,KAGNJ,EA5eT,SAAkC6D,MAC5BnE,EAAaQ,QAAUA,OAAOC,iBACzB,aAUP4C,EACAkC,EAgBMnB,EACJoB,EAEFnD,EA3BIG,EAAO,CAAChC,OAAOiF,SAASC,MAC5BC,EAAUnF,OAAOC,SAASmF,qBAAqB,UAC/CC,EAAO,GAAK1B,EAQL9C,EAAI,EAAGA,EAAIsE,EAAQvE,SAAUC,EAAG,KACjCyE,EAASH,EAAQtE,GACnByE,EAAOC,KACTvD,EAAKR,KAAK8D,EAAOC,QAmBhBR,EAASjD,GAfRe,EAdK,2EAcUzC,KAAKiF,KAOlBzB,EAAOf,EAAM,GAAK,OAASA,EAAM,GAAK,GAC1CmC,EAAOnC,EAAM,GAAGxC,MAAM,KAAK6B,KAAK,aAElCL,EAAOJ,EAAaoB,EAAM,IAAIlB,QAAQ,KAAM,MACvC,IAAIa,OAAO,WAAaoB,EAAO,cAAgBoB,EAAO,mBAAqBnD,EAAO,UAVlF,IAAIW,OAAOf,EAAa4D,GAAM1D,QAAQ,OAAQ,SAclBK,UAC1B+C,KAIJlC,EAjCO,iEAiCSzC,KAAKiF,GAAQ,KAC1BG,EAAQ3C,EAAM,MACpBhB,EAAOD,EAAwCiB,EAAM,IAKhDkC,EAASjD,EAFT,IAAIU,OAAO,KAAOgD,EAAQ,eAAiB3D,EAAO,cAAe,KAEnCG,EAAK,WAC/B+C,KAMJA,EAASjD,EAFT,IAAIU,OAAOX,GAEmBG,UAC1B+C,SAIJ,KA+aSU,CAAyBhB,MACrCJ,EAAKxE,IAAMC,EAAOD,IAClBwE,EAAK1D,KAAOb,EAAOa,KAEf0D,EAAKV,OAASjE,IAChB2E,EAAKV,KAAOrD,EAAkB+D,EAAKxE,IAAKwE,EAAK1D,QAGzC0C,EAAY,cAAcjD,KAAKsC,EAAGY,SAAWZ,EAAGgD,gBAEpDrB,EAAKX,OAASpB,EAAiBe,EAAU,GAAIvD,EAAOD,IAAKC,EAAOa,QAIhE4D,EAAM,GAAKE,GACbD,GAAY,EAEZD,EAAM,GAAKE,IAAQ,EAGrB9B,EAAMnB,KAAK6C,GAGTD,GACFzB,EAAMgD,OAAO,EAAGvB,OAGdW,EAAS,MACH,eACArC,EAAGkB,aACAlB,EAAGY,cACLX,UAEXkB,EAAoCkB,EAAQrC,EAAGkD,WAAalD,EAAGmD,SAAUnD,EAAG/B,MAAQ+B,EAAGoD,WAAYpD,EAAGY,SAAWZ,EAAGgD,aAC7GX,EAST,SAASJ,EAAkBjC,EAAI0B,OACzBzB,EAAQ,KACZyB,EAAkB,MAATA,EAAgB,GAAKA,SAM5BzB,EA7UJ,SAA6CD,OAIrCqD,EAAarD,EAAGqD,cACjBA,WAQHlD,EAJImD,EAAe,8DACnBC,EAAe,uGACf7C,EAAQ2C,EAAW1F,MAAM,MACvBsC,EAAQ,GAGHhC,EAAO,EAAGA,EAAOyC,EAAMxC,OAAQD,GAAQ,EAAG,KAC7CmC,EAAU,SACTD,EAAQmD,EAAa5F,KAAKgD,EAAMzC,KACnCmC,EAAU,KACDD,EAAM,SACJA,EAAM,UACL,UACFA,EAAM,QACP,KAECA,EAAQoD,EAAa7F,KAAKgD,EAAMzC,OAC1CmC,EAAU,KACDD,EAAM,SACJA,EAAM,WACJA,EAAM,QACTA,EAAM,IAAMA,EAAM,QAClBA,EAAM,GAAKA,EAAM,GAAGxC,MAAM,KAAO,KAIzCyC,EAAS,KACNA,EAAQa,MAAQb,EAAQnC,OAC3BmC,EAAQa,KAAOrD,EAAkBwC,EAAQjD,IAAKiD,EAAQnC,OAEpDmC,EAAQnC,SAERmC,EAAQ/B,QAAUD,EAAcgC,EAAQjD,IAAKiD,EAAQnC,MACrD,MAAOuF,IAGNpD,EAAQ/B,UACX+B,EAAQ/B,QAAU,CAACqC,EAAMzC,EAAO,KAGlCgC,EAAMnB,KAAKsB,WAIVH,EAAM/B,OAIJ,MACG,kBACA8B,EAAGkB,aACAlB,EAAGY,cACLX,GAPF,MAuRCwD,CAAoCzD,UAEnCC,EAET,MAAOzC,WAOPyC,EAAQF,EAA+BC,UAE9BC,EAET,MAAOzC,WAOPyC,EAxRJ,SAAoDD,OAgB5CU,EAAQV,EAAGY,QAAQjD,MAAM,SAC3B+C,EAAMxC,OAAS,SACV,SASPiC,EANIuD,EAAU,yFACdC,EAAU,kGACVC,EAAU,yCACV3D,EAAQ,GACRwC,EAAWnF,QAAUA,OAAOC,UAAYD,OAAOC,SAASmF,qBAAqB,UAC3EmB,EAAqB,OAGpB,IAAIC,KAAKrB,EACRlG,EAAKkG,EAASqB,KAAOrB,EAAQqB,GAAGjB,KAClCgB,EAAmB/E,KAAK2D,EAAQqB,QAI/B,IAAI7F,EAAO,EAAGA,EAAOyC,EAAMxC,OAAQD,GAAQ,EAAG,KAkBzC8F,EACAnB,EAEAxF,EAGI4G,EAOJ7G,EAEA0F,EAcAxE,EACA4F,EA/CJtC,EAAO,MACNxB,EAAQuD,EAAQhG,KAAKgD,EAAMzC,KAC9B0D,EAAO,KACExB,EAAM,QACLA,EAAM,QACN,SACCA,EAAM,UACL,OAEFA,EAAQwD,EAAQjG,KAAKgD,EAAMzC,MACrC0D,EAAO,KACExB,EAAM,QACLA,EAAM,QACN,SACCA,EAAM,UACL,MAEN4D,GAAiB5D,EAAM,IACvByC,EAASiB,EAAmB1D,EAAM,GAAK,QAEvC/C,EAASF,EAAUyE,EAAKxE,OAIf,IADL6G,GADN5G,EAASA,EAAOoC,KAAK,OACFsB,QAAQ8B,EAAOsB,cAEhCvC,EAAK1D,KAAO8F,EAAe3G,EAAOqC,UAAU,EAAGuE,GAAKrG,MAAM,MAAMO,WAI5DiC,EAAQyD,EAAQlG,KAAKgD,EAAMzC,OAIrC0D,EAAO,KAHDxE,EAAMG,OAAOiF,SAASC,KAAKvD,QAAQ,OAAQ,SAKvC,QACA,SAJJ4D,EAAMzD,EADD,IAAIU,OAAOZ,EAAwCwB,EAAMzC,EAAO,KAC1C,CAACd,KAKlB0F,EAAI5E,KAAOkC,EAAM,UACrB,OAIVwB,IACGA,EAAKV,OACRU,EAAKV,KAAOrD,EAAkB+D,EAAKxE,IAAKwE,EAAK1D,OAGzCgG,GADA5F,EAAUD,EAAcuD,EAAKxE,IAAKwE,EAAK1D,OAClBI,EAAQE,KAAKC,MAAMH,EAAQH,OAAS,IAAM,KACjEG,GAAW4F,EAAQhF,QAAQ,OAAQ,MAAQyB,EAAMzC,EAAO,GAAGgB,QAAQ,OAAQ,IAC7E0C,EAAKtD,QAAUA,EAGfsD,EAAKtD,QAAU,CAACqC,EAAMzC,EAAO,IAE/BgC,EAAMnB,KAAK6C,WAGV1B,EAAM/B,OAIJ,MACG,iBACA8B,EAAGkB,aACAR,EAAM,SACRT,GAPF,KA0LCkE,CAA2CnE,UAE1CC,EAET,MAAOzC,WAOPyC,EAAQwB,EAAsCzB,EAAI0B,EAAQ,UAEjDzB,EAET,MAAOzC,UAMF,MACGwC,EAAGkB,aACAlB,EAAGY,aACN,UAmBZqB,EAAkBd,oCAAsCA,EACxDc,EAAkBlC,+BAAiCA,EACnDkC,EAAkBrE,kBAAoBA,EACtCqE,EAAkB7D,cAAgBA,EAClC6D,EAAkBmC,SAblB,SAAmC1C,GACjCA,EAAuC,GAArB,MAATA,EAAgB,GAAKA,aAEtB,IAAI2C,MACV,MAAOrE,UACAiC,EAAkBjC,EAAI0B,EAAQ,KASzCO,EAAkB/E,UAAYA,ECv5B9B,IAAIoH,GAAqB,EACrBC,EAAW,KCgDf,IAgEIC,EAAoBC,EACpBC,EAAiCC,EAjE/BC,EAAiB,0GAGnBC,EAAW,GACbC,EAAgB,KAChBC,EAAqB,KAuCvB,SAASC,EAAe/E,EAAOgF,EAAeC,OACxCC,EAAY,SACZF,GAAkB9I,OAGjB,IAAIgC,KAAK0G,KACRtI,EAAKsI,EAAU1G,OAEf0G,EAAS1G,GAAG8B,EAAOgF,EAAeC,GAClC,MAAOE,GACPD,EAAYC,KAKdD,QACIA,GAiBV,SAASE,EAAwBzE,EAASzD,EAAKU,EAAQyH,EAAUC,OAUzDhD,EAMArB,EACAsE,EAEIC,SAhBNV,GACF9C,EAAkBd,oCAAoC4D,EAAoB5H,EAAKU,EAAQ+C,GACvF8E,KACSH,EAETP,EADQ/C,EAAkBsD,IACJ,EAAMA,IAExBhD,EAAW,KACNpF,OACCU,SACEyH,GAIRE,EAAM5E,EACwB,oBAA9B,GAAGuB,SAAStF,KAAK+D,KACb6E,EAAS7E,EAAQnD,MAAMmH,MAE3B1D,EAAOuE,EAAO,GACdD,EAAMC,EAAO,IAIjBlD,EAAStB,KAAOgB,EAAkBrE,kBAAkB2E,EAASpF,IAAKoF,EAAStE,MAC3EsE,EAASlE,QAAU4D,EAAkB7D,cAAcmE,EAASpF,IAAKoF,EAAStE,MAQ1E+G,EAPQ,MACE9D,UACGsE,OACH,gBACC,CAACjD,KAGU,EAAM,SAG1BiC,GACKA,EAAmBmB,MAAMC,KAAMC,WAa1C,SAASC,EAAqCtI,GAE5CwH,EADc/C,EAAkBzE,EAAEuI,SACZ,EAAMvI,EAAEuI,QA6DhC,SAASL,QACHM,EAAsBjB,EACxBkB,EAAiBnB,EAEnBA,EADAC,EAAqB,KAErBC,EAAegB,GAAqB,EAAOC,GAS7C,SAASC,EAAOlG,MACV+E,EAAoB,IAClBD,IAAkB9E,SAGpB0F,QAIEzF,EAAQgC,EAAkBjC,SAChC+E,EAAqB9E,EACrB6E,EAAgB9E,EAMhBmG,WAAW,WACLrB,IAAkB9E,GACpB0F,KAEAzF,EAAMqB,WAAa,IAAO,GAExBtB,EC9QD,SAASoG,EAAKnF,gCAGRA,EAAK0E,MAAMC,KAAMC,WACxB,MAAOrI,SACP0I,EAAO1I,GACDA,ID2QZ0I,EAAOG,UA5NP,SAAmBC,IA8HnB,eACmC,IAA7B7B,SAIJD,EAAqBlH,OAAOiJ,QAC5BjJ,OAAOiJ,QAAUlB,ED1LZ,SAAkCiB,IACnChC,GAAsBlI,IACxBmI,EAAW+B,EACXhJ,OAAOkJ,kBAAoBlJ,OAAOkJ,iBAAiB,QAAS,SAAUhJ,WAG1DyC,EADLzC,EAAEiJ,SAAWnJ,SACR2C,EAAQ,CACZW,kBAAYpD,EAAEiJ,OAAOC,4BACrBC,KAAM,WACNzF,KAAM1D,EAAEiJ,OAAO5D,KAAOrF,EAAEiJ,OAAOjE,MAAQhF,EAAEiJ,OAAOG,WAChD3G,MAAO,MAETqG,EAAQrG,GAAO,EAAMzC,IAEvB,MAAOA,SACDA,KAEP,IAEL8G,GAAqB,ECwKrBuC,CAAyB,SAA6B5G,EAAOgF,EAAeC,GAC1EF,EAAe/E,EAAOgF,EAAeC,KAEvCT,GAA2B,EAvI3BqC,GA0JF,eACgD,IAA1CnC,SAIJD,EAAkCpH,OAAOyJ,qBACzCzJ,OAAOyJ,qBAAuBjB,EAC9BnB,GAAwC,EAhKxCqC,GACAnC,EAAS/F,KAAKwH,IA0NhBJ,EAAOe,YAlNP,SAAqBX,OACd,IAAInI,EAAI0G,EAAS3G,OAAS,EAAQ,GAALC,IAAUA,EACtC0G,EAAS1G,KAAOmI,GAClBzB,EAAS5B,OAAO9E,EAAG,GAIC,IAApB0G,EAAS3G,SA8HTuG,IACFnH,OAAOiJ,QAAU/B,ED7KhBF,GAAsBlI,GAAuBmI,IAC9CjH,OAAO4J,qBAAuB5J,OAAO4J,oBAAoB,QAAS3C,GAClEA,EAAW,KACXD,GAAqB,GC4KrBG,GAA2B,GAuBzBE,IACFrH,OAAOyJ,qBAAuBrC,EAC9BC,GAAwC,KAmD5CuB,EAAOhE,SAAW5F,EE3RlB,IAAM6K,EAAS,GAAGC,MAOlB,SAASC,EAAQC,OACTC,EAAajK,OAAOgK,GAE1BhK,OAAOgK,GAAU,eAEXhF,EAAO6E,EAAOtK,KAAKgJ,WACjB2B,EAAmBlF,EAAK,SACI,mBAAtBkF,IACVlF,EAAK,GAAK8D,EAAKoB,IAKbD,EAAW5B,MACN4B,EAAW5B,MAAMC,KAAMtD,GAEvBiF,EAAWjF,EAAK,GAAIA,EAAK,KCrBtC,IACImF,EADEC,EAAiBpK,OAAOmK,kBAkB9BA,EAAc,CACZE,WAXF,kBACErK,OAAOmK,WAAaC,EACbD,GAUPvB,OAAAA,EACAjE,kBAAAA,EACAmE,KAAAA,EACAwB,8BDGK,WACLP,EAAQ,cACRA,EAAQ,gBCJRQ,UAXF,kBACcC,WACC"}